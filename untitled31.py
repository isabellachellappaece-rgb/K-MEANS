# -*- coding: utf-8 -*-
"""Untitled31.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10EsidaUH9bnU8iTJtB6brtMMbqOg5ivI
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_blobs

class KMeansFromScratch:
    def __init__(self, k=3, max_iters=100, tol=1e-4):
        self.k = k
        self.max_iters = max_iters
        self.tol = tol
        self.centroids = None
        self.inertia_ = 0

    def fit(self, X):
        # 1. Initialization: Simple random selection from the dataset
        random_indices = np.random.choice(len(X), self.k, replace=False)
        self.centroids = X[random_indices]

        for i in range(self.max_iters):
            # 2. Assignment Step: Use broadcasting for Euclidean distance
            distances = np.linalg.norm(X[:, np.newaxis] - self.centroids, axis=2)
            labels = np.argmin(distances, axis=1)

            # 3. Update Step: Recalculate centroids as the mean of cluster points
            # Handles empty clusters by keeping the previous centroid
            new_centroids = np.array([X[labels == j].mean(axis=0) if len(X[labels == j]) > 0
                                      else self.centroids[j] for j in range(self.k)])

            # 4. Convergence Check: Stop if centroids shift less than the tolerance
            if np.all(np.abs(new_centroids - self.centroids) < self.tol):
                break
            self.centroids = new_centroids

        # Calculate final Within-Cluster Sum of Squares (WCSS) for the Elbow Method
        final_distances = np.linalg.norm(X[:, np.newaxis] - self.centroids, axis=2)
        min_distances = np.min(final_distances, axis=1)
        self.inertia_ = np.sum(min_distances**2)
        return labels

# --- 1. Synthetic Data Generation ---
# Generating 300 samples with 4 distinct centers as required
X, true_labels = make_blobs(n_samples=300, centers=4, cluster_std=0.60, random_state=0)

# --- 2. Elbow Method Analysis (Deliverable 2) ---
print("--- WCSS Values for K=1 through K=10 ---")
inertias = []
K_range = range(1, 11)
for k in K_range:
    model = KMeansFromScratch(k=k)
    model.fit(X)
    inertias.append(model.inertia_)
    print(f"K = {k}: WCSS = {model.inertia_:.2f}")

# --- 3. Visualization ---
plt.figure(figsize=(12, 5))

# Plotting the Elbow Curve
plt.subplot(1, 2, 1)
plt.plot(K_range, inertias, 'bx-')
plt.xlabel('Number of clusters (K)')
plt.ylabel('WCSS (Inertia)')
plt.title('Elbow Method for Optimal K')

# Final Clustering Result using the optimal K identified from the plot
optimal_k = 4
model = KMeansFromScratch(k=optimal_k)
labels = model.fit(X)
plt.subplot(1, 2, 2)
plt.scatter(X[:, 0], X[:, 1], c=labels, s=30, cmap='viridis')
plt.scatter(model.centroids[:, 0], model.centroids[:, 1], c='red', marker='X', s=200, label='Centroids')
plt.title(f'Final Clustering Result (K={optimal_k})')
plt.legend()
plt.show()